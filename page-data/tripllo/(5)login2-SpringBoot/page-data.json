{"componentChunkName":"component---src-templates-post-tsx","path":"/tripllo/(5)login2-SpringBoot/","result":{"data":{"logo":{"childImageSharp":{"fixed":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAACY0lEQVQ4y42UTUhUURTHz7kzFiN9aLsSK5JIGV2URREGBX2ppKGUptVMZYJ9OPPemzfjyloXSDsXtRD6oFVUIFGtTHARFoEgSiFkJRFWGBPavHfvP+6rbLIZ9XIWh8P98T/vvP+5FCVkjAgpi5TpJdnuUMZqO7kJQq3v/lHRH9e8XDysDEKEZ1bw+gKuiP0WV4uC28lJCOyky7nlwUDJxv10PcG6uDAcIWkRzvJ4gPKDTweKeu7kUeFFkTS8jhaE3YQPpXQst66qfgbVX7CkonwHxTtEBnGaQ9qMBnq2dOWqksHRAYmHwLpHfbki/7R4bf03uXRYTyXmRyFty0vYpgJcZ9pxww6WhZo2UW2HLzusGxbYTV3+DWu2v50akgAUlOxTKH017s9bfojuxVlfy6xsCOyjrqLu3isAXCk1DTjSBoo6b1bTDetf8TRlHyzCmUocTKqPjvJ0oeWBEUfu+aTatsAkREXGthkxQpWVuj2Z0sIKv470kmvvUzWhlE2IZIQNgXOEq2XKnfZk/8DKU09OqEur1QWCwVng84T+bpX8hs9j+Dr+NybH8D2J3k7VRjB8Wf6zIRALuIZfmjnSyHFNHdLQ4Rh+GQvIKMv5HBYjmHoxlKlXUk/I9IpRkiapWDaHGXolflSKW838IszDzTxYz49DPBzi0Spxt5XfHeeXTTxoppmcZh0SJxzm3rVib1CEN4v2oAiXiZYCsatYNBaLxgPcs1XYR7jPTjPprLJ+NFroQ4Smmvl5Aw/U8IOTPHyCh07xm1aeqOMnYR6x5lkMryVpkbIJcdKemf1s28vnbOVPfGtgRKO972EAAAAASUVORK5CYII=","width":400,"height":400,"src":"/static/8c061761f263c344f2c0416607c8adf1/3891b/pozafly.png","srcSet":"/static/8c061761f263c344f2c0416607c8adf1/3891b/pozafly.png 1x,\n/static/8c061761f263c344f2c0416607c8adf1/8c332/pozafly.png 1.5x,\n/static/8c061761f263c344f2c0416607c8adf1/bc8e0/pozafly.png 2x"}}},"markdownRemark":{"html":"<blockquote>\n<p>Spring Security와 JWT를 사용해서 로그인 기능을 구현했다. Spring Security의 구현된 소스와 login의 Service 단 내부 로직을 개념에 맞춰서 알아보자.</p>\n</blockquote>\n<br/>\n<p>이제 실제적으로 SpringBoot부터 구현하자.</p>\n<h2>Dependency 등록</h2>\n<p>첫번째로, build.gradle에 dependencies를 추가해주자.</p>\n<deckgo-highlight-code   terminal=\"carbon\" theme=\"material\"  highlight-lines=\"undefined\">\n          <code slot=\"code\">implementation &#39;org.springframework.boot:spring-boot-starter-security&#39;\nimplementation &#39;io.jsonwebtoken:jjwt:0.9.1&#39;</code>\n        </deckgo-highlight-code>\n<br/>\n<h2>Common 세팅</h2>\n<p>common이란 패키지 밑에 security 패키지를 만들었다. 이곳에 이제 Security 관련 class들이 들어갈 예정이다. 그 밑에 UserService 관련 객체가 들어갈 securityUser 패키지를 만들고 Spring Security의 전체 구조 사진의 5,6,7 번에 해당하는 UserDetailsService, UserDetail을 구현한 클래스를 만들었다.</p>\n<h3>SecurityUser</h3>\n<deckgo-highlight-code java  terminal=\"carbon\" theme=\"material\"  highlight-lines=\"\">\n          <code slot=\"code\">package com.pozafly.tripllo.common.security.securityUser;\n\nimport com.pozafly.tripllo.user.model.User;   // security 외에 Tripllo에서 직접 사용하는 User class\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\n\npublic class SecurityUser implements UserDetails {\n\n    private Collection&lt;? extends GrantedAuthority&gt; authorities;\n    private User user;   // 이곳에 Tripllo의 User 객체를 넣어준다.\n\n    @Override\n    public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return authorities; }\n    @Override\n    public String getPassword() { return user.getPassword(); }     // 패스워드를 들고오는 부분\n    @Override\n    public String getUsername() { return user.getId(); }   // id를 들고오는 부분\n    @Override\n    public boolean isAccountNonExpired() { return true; }\n    @Override\n    public boolean isAccountNonLocked() { return true; }\n    @Override\n    public boolean isCredentialsNonExpired() { return true; }\n    @Override\n    public boolean isEnabled() { return true; }\n}</code>\n        </deckgo-highlight-code>\n<p>UserDetails를 구현한 class이다. UserDetails는 SpringSecurity의 인터페이스이고, 우리 프로젝트에서 만든 인터페이스가 아니다. Tripllo에서 사용하는 객체는 User 하나다. 제일 위 사진을 보면 6번에 해당하는 UserDetails 를 구현체로 한 구현 class가 해당 class이며 이는 Tripllo에서 실제로 사용하는 User 객체의 id, pw를 사용하는 모습을 볼 수 있다.</p>\n<br/>\n<h3>UserDetailsService</h3>\n<deckgo-highlight-code java  terminal=\"carbon\" theme=\"material\"  highlight-lines=\"\">\n          <code slot=\"code\">package com.pozafly.tripllo.common.security.securityUser;\n\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\n\npublic interface UserDetailsService {\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;\n}</code>\n        </deckgo-highlight-code>\n<p>다음으로 볼 것은 위 그림에 5,6,7 번이 모두 물려있는 UserDetailService다. 이 인터페이스는 구현체인 UserDetailServiceImpl에서 이어지는데 하나의 메서드만 가지고 있다. <code>loadUserByUsername()</code>. 이 메서드 또한 SpringSecurity에서 자체적으로 제공하는 메서드인데 매개변수로 String username이 들어간다. 이름에서 알 수 있듯, username이라는 구분 값으로 DB에 접속해서 user의 정보를 가져오는 메서드.</p>\n<br/>\n<h3>UserDetailServiceImpl</h3>\n<deckgo-highlight-code java  terminal=\"carbon\" theme=\"material\"  highlight-lines=\"\">\n          <code slot=\"code\">package com.pozafly.tripllo.common.security.securityUser;\n\nimport com.pozafly.tripllo.user.dao.UserDao;\nimport com.pozafly.tripllo.user.model.User;\nimport lombok.extern.log4j.Log4j2;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n@Log4j2\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    @Autowired\n    private UserDao userDao;   // Tripllo 유저 조회하기 위해 DI\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        // 로그인 시도하려는 유저정보 조회\n        log.info(&quot;security loadUserByUsername에서 유저 조회&quot;);\n        User user = userDao.readUser(username);   // tripllo에서 사용하는 User 조회 메서드\n\n        // 조회가 되지않는 User는 에러발생.\n        if(user == null){ throw new UsernameNotFoundException(username); }\n\n        // 조회한 정보를 userCustom에 담는다.\n        // 만약 파라미터를 추가해야한다면 UserCustom 을 먼저 수정한다.\n        return new SecurityUser() {\n            @Override\n            public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() {\n                List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;GrantedAuthority&gt;();\n                authorities.add(new SimpleGrantedAuthority(user.getRole()));  // Role을 위해\n                return authorities;\n            }\n            @Override\n            public String getPassword() { return user.getPassword(); }\n            @Override\n            public String getUsername() { return user.getId(); }\n            @Override\n            public boolean isAccountNonExpired() { return true; }\n            @Override\n            public boolean isAccountNonLocked() { return true; }\n            @Override\n            public boolean isCredentialsNonExpired() { return true; }\n            @Override\n            public boolean isEnabled() { return true; }\n        };\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>구현체인 UserServiceImpl 에서는 <code>loadUserByUsername()</code>를 정의해준다. Tripllo에서 사용하는 user를 조회하는 Dao를 DI해서 MyBatis로 연결되어 유저 정보를 조회해서 가져오고, username에는 user.getId(), password에는 user.getId()를 사용해서 넣어주었다. Role에 대해서는 밑에서 설명 예정.</p>\n<br/>\n<h3>JwtTokenProvider</h3>\n<deckgo-highlight-code java  terminal=\"carbon\" theme=\"material\"  highlight-lines=\"\">\n          <code slot=\"code\">package com.pozafly.tripllo.common.security;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jws;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.Base64;\nimport java.util.Date;\nimport java.util.List;\n\n@RequiredArgsConstructor\n@Component\npublic class JwtTokenProvider {\n\n    private static String secretKey = &quot;triplloApplication&quot;;\n\n    // 토큰 유효시간 60분 * 24 = 24시간\n    private long tokenValidTime = 60 * 60 * 24 * 1000L;\n\n    private final UserDetailsService userDetailsService;\n\n    // 객체 초기화, secretKey를 Base64로 인코딩한다.\n    @PostConstruct\n    protected void init() {\n        secretKey = Base64.getEncoder().encodeToString(secretKey.getBytes());\n    }\n\n    // JWT 토큰 생성\n    public String createToken(String userPk, List&lt;String&gt; roles) {\n        Claims claims = Jwts.claims().setSubject(userPk); // JWT payload 에 저장되는 정보단위\n        claims.put(&quot;roles&quot;, roles); // 정보는 key / value 쌍으로 저장된다.\n        Date now = new Date();\n        return Jwts.builder()\n                .setClaims(claims) // 정보 저장\n                .setIssuedAt(now) // 토큰 발행 시간 정보\n                .setExpiration(new Date(now.getTime() + tokenValidTime)) // set Expire Time\n                .signWith(SignatureAlgorithm.HS256, secretKey)  // 사용할 암호화 알고리즘, signature 에 들어갈 secret값 세팅\n                .compact();\n    }\n\n    // JWT 토큰에서 인증 정보 조회\n    public Authentication getAuthentication(String token) {\n        UserDetails userDetails = userDetailsService.loadUserByUsername(this.getUserPk(token));\n        return new UsernamePasswordAuthenticationToken(userDetails, &quot;&quot;, userDetails.getAuthorities());\n    }\n\n    // 토큰에서 회원 정보 추출\n    public String getUserPk(String token) {\n        return Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token).getBody().getSubject();\n    }\n\n    // Request의 Header에서 token 값을 가져옴. &quot;Authorization&quot; : &quot;TOKEN값&#39;\n    public String resolveToken(HttpServletRequest request) {\n        return request.getHeader(&quot;Authorization&quot;);\n    }\n\n    // 토큰의 유효성 + 만료일자 확인\n    public boolean validateToken(String jwtToken) {\n        try {\n            Jws&lt;Claims&gt; claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwtToken);\n            return !claims.getBody().getExpiration().before(new Date());\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>위의 사진에 4,5,7,8번이 물려있는 AuthenticationProviders의 하나인 JwtTokenProvider를 만들어주었다.</p>\n<ul>\n<li>init() : 상단의 secretKey 상수에 물려있는 String 값을 기반으로 Base64 로 인코딩해서 토큰을 생성한다. 물론 이 부분은 application.properties나 application.yml로 빼서 @Value 로 받아와 사용하는것이 좋겠다.</li>\n<li>createToken() : userPK(가령 id)와 role list를 매개변수로 받아 Claims를 생성하고, role을 Claims에 집어넣난다. Builder 패턴으로 정보, 토큰 발행시간, 토큰 유효시간, 그리고 사용할 알고리즘을 세팅한다.</li>\n<li>getAuthentication() : 위에서 생성했던 loadUserByUsername() 메서드를 여기서 사용한다. 클라이언트로부터 받은 token을 파싱해서 이름을 추출하고 userDetails를 가져온다. return 객체는 사진 2번에 물려있는 <code>UsernamePasswordAuthenticationToken</code>이다. 이 녀석이 핵심!</li>\n<li>getUserPk() : 토큰에서 회원 정보 추출.</li>\n<li>validateToken() : 토큰의 유효성 검사.</li>\n<li>resolveToken() : 이녀석을 유의해서 봐야하는데 이녀석 때문에 몇시간을 헤멘지 모르겠다. 중요한 것은</li>\n</ul>\n<deckgo-highlight-code java  terminal=\"carbon\" theme=\"material\"  highlight-lines=\"\">\n          <code slot=\"code\">return request.getHeader(&quot;Authorization&quot;);</code>\n        </deckgo-highlight-code>\n<p>이 부분이다. vue에서 axios로 api를 날릴때 token 이름을 “Token …” 이런식으로 주었더니 토큰을 가져오지 못하는 경우가 발생했다.</p>\n<img width=\"1038\" alt=\"스크린샷 2021-02-04 오후 9 18 58\" src=\"https://user-images.githubusercontent.com/59427983/106891971-c79c5500-672e-11eb-8840-2377296e626c.png\">\n<p>개발자 도구에 Network 탭에서 확인해보자. 만약 위 코드를</p>\n<deckgo-highlight-code java  terminal=\"carbon\" theme=\"material\"  highlight-lines=\"\">\n          <code slot=\"code\">return request.getHeader(&quot;Token&quot;);</code>\n        </deckgo-highlight-code>\n<p>이라고 했다고 하자. 그럼 클라이언트 단에서 <strong>Authorization</strong> 이라는 header 명으로 axios에서 요청을 보냈다. 그러자 Spring Security에서 인증되지 않아 403 인증 오류를 뱉는다. 즉, resolveToken() 메서드의 getHeader(“Authorization”) 이렇게 이름을 맞춰주거나, axios 로 http call을 날릴 때 헤더명을 “Token” 으로 맞춰주거나 해야 한다.</p>\n<br/>\n<h3>JwtAuthenticationFilter</h3>\n<deckgo-highlight-code java  terminal=\"carbon\" theme=\"material\"  highlight-lines=\"\">\n          <code slot=\"code\">package com.pozafly.tripllo.common.security;\n\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.web.filter.GenericFilterBean;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\n@RequiredArgsConstructor\npublic class JwtAuthenticationFilter extends GenericFilterBean {\n\n    private final JwtTokenProvider jwtTokenProvider;\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        // 헤더에서 JWT 를 받아옴.\n        String token = jwtTokenProvider.resolveToken((HttpServletRequest) request);\n\n        // 유효한 토큰인지 확인함.\n        if (token != null &amp;&amp; jwtTokenProvider.validateToken(token)) {\n            // 토큰이 유효하면 토큰으로부터 유저 정보를 받아옴.\n            Authentication authentication = jwtTokenProvider.getAuthentication(token);\n            // SecurityContext 에 Authentication 객체를 저장함.\n            SecurityContextHolder.getContext().setAuthentication(authentication);\n        }\n        chain.doFilter(request, response);\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>이번엔 클라이언트에서 가장 먼저 접근했을 때 들어오는 Filter인, <code>JwtAuthenticationFilter</code> 를 살펴보자. 모든 filter는 요청이 들어왔을 때 doFilter() 메서드가 실행되며, 마칠 때 다른 filter 가 있다면 chain을 걸어주어야 한다. Provider에서 토큰을 받아오고, 다시 Provider에서 검증하는 과정을 거친다. 이제 마지막 부분인 config 부분을 보자. 이때까지 setting 이었다면, 이번에는 실질적으로 이 config 파일에서 모든 설정을 해줄 수 있다.</p>\n<deckgo-highlight-code java  terminal=\"carbon\" theme=\"material\"  highlight-lines=\"\">\n          <code slot=\"code\">package com.pozafly.tripllo.common.security;\n\nimport com.google.common.collect.ImmutableList;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.factory.PasswordEncoderFactories;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.CorsConfigurationSource;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\n\n@Configuration\n@RequiredArgsConstructor\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    private final JwtTokenProvider jwtTokenProvider;\n\n    // 암호화에 필요한 PasswordEncoder를 Bean으로 등록함.\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    // authenticationManager를 Bean 등록함.\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    // 여기는 CORS 설정임.\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n      final CorsConfiguration configuration = new CorsConfiguration();\n      configuration.setAllowedOrigins(ImmutableList.of(&quot;http://localhost:8080&quot;, &quot;http://tripllo.tech.s3-website.ap-northeast-2.amazonaws.com&quot;, &quot;http://tripllo.tech&quot;, &quot;https://tripllo.tech&quot;));\n      configuration.setAllowedMethods(ImmutableList.of(&quot;HEAD&quot;,&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;, &quot;PATCH&quot;, &quot;OPTIONS&quot;));\n      configuration.setAllowCredentials(true);\n      // 토큰을 Authorization 이라는 이름으로 받겠다.\n      configuration.setAllowedHeaders(ImmutableList.of(&quot;Authorization&quot;, &quot;Cache-Control&quot;, &quot;Content-Type&quot;));\n      final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n      source.registerCorsConfiguration(&quot;/**&quot;, configuration);\n      return source;\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n          .httpBasic().disable() // rest api 만을 고려하여 기본 설정은 해제.\n          .csrf().disable() // csrf 보안 토큰 disable처리.\n          .formLogin().disable() //기본 로그인 페이지 없애기\n          .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 토큰 기반 인증이므로 세션 역시 사용하지 않음.\n          .and()\n            .authorizeRequests() // 요청에 대한 사용권한 체크\n            //                .antMatchers(&quot;/admin/**&quot;).hasRole(&quot;ADMIN&quot;)\n            .antMatchers(&quot;/profile&quot;).permitAll()\n            .antMatchers(&quot;/websocket/**&quot;).permitAll()\n            // post 방식의 user create(회원가입)은 허용한다.\n            .antMatchers(HttpMethod.POST, &quot;/api/user&quot;).permitAll()\n            // 회원가입 전 사용하고 싶은 회원 id를 validation 해볼 수 있는 api도 open\n            .antMatchers(&quot;/api/user/valid/**&quot;).permitAll()\n            // 로그인 오픈\n            .antMatchers(&quot;/api/login/**&quot;).permitAll()\n            .antMatchers(&quot;/api/logout&quot;).permitAll()\n            .antMatchers(&quot;/api/email/**&quot;).permitAll()\n\n            // 인증된 사용자만 가능하다(즉, 헤더에 토큰을 준 사람만이 가능한 것임.)\n            .antMatchers(&quot;/api/**&quot;).authenticated()\n            // role이 ROLE_USER 인 역할만 통과\n            .antMatchers(&quot;/api/**&quot;).hasRole(&quot;USER&quot;)\n            .anyRequest().authenticated()   // 그외 나머지 요청은 인증 가능 해야한다.\n          .and()\n\t          .cors()\n          .and()\n          \t.addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider),\n                             \tUsernamePasswordAuthenticationFilter.class)\n        // JwtAuthenticationFilter를 UsernamePasswordAuthenticationFilter 전에 넣는다\n                ;\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>하나씩 천천히 들여다보자.</p>\n<ul>\n<li>JwtTokenProvider를 마찬가지로 DI 받아서 사용한다.</li>\n<li>Spring Security라이브러리에서 제공하는 BCryptPasswordEncoder를 사용한다.</li>\n<li>사진의 3,4,8,9에 물려있는 AuthenticationManager를 Bean으로 등록해준다.</li>\n<li>\n<p>corsConfigurationSource 는 cors 설정이다. cors는 제작기를 따로 만들어서 다룰 예정이지만 가볍게 짚고 넘어가보자. cors란, 서로 다른 도메인 간 api response를 막는걸 말한다. 쉽게 말해 vue는 <strong>8080</strong> 포트를 사용하고, SpringBoot는 <strong>3000</strong>포트를 사용하는데 포트가 다르기 때문에 리소스를 막아주는 역할을 한다.</p>\n<p>SpringSecurity를 도입하기 전에는 WebMvcConfigurer를 상속받은 CorsConfig class를 따로 만들어서 해결했지만, 여기서 cors 설정을 해주면 CorsConfig 가 무시되므로 여기서 보면된다.</p>\n<ul>\n<li>setAllowedOrigins() : url에 해당하는 출처를 허가하겠다라는 뜻이다. ImmutableList.of() 안에 허용하고 싶은 도메인들을 String 형식으로 적어주면 된다.</li>\n<li>setAllowedMethods() : 허용하고 싶은 http 메서드를 마찬가지로 적어준다. 가령 “GET”, “POST”, “PUT”, “DELETE”, “OPTIONS” 같은 메서드들.</li>\n<li>setAllowCredentials() : true일 때, header가 없는 응답들은 거르겠다는 뜻이다. header가 있어야 함을 의미.</li>\n<li>addAllowedHeaders() : 어떤 이름으로 된 헤더들을 허용하겠느냐? ※addAllowedHeader(”*”) 로 모든 헤더 허용 가능.</li>\n<li>그리고 모든 설정한 configuration을 등록해준다.</li>\n</ul>\n</li>\n<li>\n<p>configure 메서드에서 SpringSecurity 설정을 해줄 수 있다.</p>\n<ul>\n<li>httpBasic().disable() : rest api 이므로 기본설정 사용안함. 기본설정은 비인증시 로그인폼 화면으로 리다이렉트 됨.(vue를 사용할 것이므로.)</li>\n<li>.csrf().disable() : 마찬가지로 rest api이므로 csrf 보안이 필요없으므로 disable처리.</li>\n<li>STATELESS 란 무상태성, 비보존한다는 뜻이다. 마찬가지로, 우리는 토큰 기반으로 인증을 계속 할것이기 때문에 세션이 필요없으므로 STATELESS를 사용한다.</li>\n</ul>\n<blockquote>\n<p>★위 3가지가 중요하다. react 나 vue 같이 서버단에서 화면을 보여주는것이 아니라 따로 존재하는 프론트 단에서는 위 설정이 필요없기 때문이다.</p>\n</blockquote>\n<ul>\n<li>antMatchers() 는 http 메서드와 url을 적어줄 수 있는데 controller에서 접근하는 url을 말한다. 뒤에 따라오는 .permitAll()은 모두 허용하겠다는 뜻이된다.</li>\n<li>.antMatchers(“/api/**“).authenticated() 이 부분은 헤더에 토큰은 준 user만 허락한다는 뜻이 된다.</li>\n<li>.antMatchers(“/api/**“).hasRole(“USER”) : 이부분은 role에 대한 부분이다. role이 밑에서 설명하겠다.</li>\n<li>그리고 마지막으로 우리가 만들어준 JwtAuthenticationFilter 와 사용하는 UsernamePasswordAuthenticationFilter 를 등록하고 마친다.</li>\n</ul>\n</li>\n</ul>\n<p>참고자료 : <a href=\"https://dongdd.tistory.com/175\">https://dongdd.tistory.com/175</a>, <a href=\"https://postitforhooney.tistory.com/entry/SpringSecurity-%EC%B4%88%EB%B3%B4%EC%9E%90%EA%B0%80-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-Spring-Security-%ED%8D%BC%EC%98%B4\">https://postitforhooney.tistory.com/entry/SpringSecurity-%EC%B4%88%EB%B3%B4%EC%9E%90%EA%B0%80-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-Spring-Security-%ED%8D%BC%EC%98%B4</a>, <a href=\"https://velog.io/@tlatldms/Spring-boot-Spring-security-JWT-Redis-mySQL-2%ED%8E%B8\">https://velog.io/@tlatldms/Spring-boot-Spring-security-JWT-Redis-mySQL-2%ED%8E%B8</a></p>\n<h4>Role에 대해서</h4>\n<p>role이란, <code>역할</code>을 말한다. Workbench의 user 테이블을 보자.</p>\n<img width=\"94\" alt=\"스크린샷 2021-02-04 오후 10 22 33\" src=\"https://user-images.githubusercontent.com/59427983/106898417-80669200-6737-11eb-8387-4860cadc36e2.png\">\n<p>이렇게 role이라는 column이 있고 ROLE<em>USER라는 값이 String으로 들어있다. spring security의 config 파일에 보면 .antMatchers(“/api/\\</em>*“).hasRole(“USER”) 이렇게 되어있다. role을 config에 등록해서, 어떤 api 호출이 가능한지 분기를 태울 수 있다는 말이된다. 그리고 hasRole에 USER 라는 값이 있으면 prefix 로 자동으로 앞에 **ROLE<em>\\</em>* 이라는 값을 붙여서 검증한다. 즉, 일반 유저라는 뜻이 되는 것이고, 만약 user 테이블에 ROLE_ADMIN 의 값을 주고 .antMatchers(“/api/**“).hasRole(“ADMIN”) 이렇게 하면 api에 해당하는 모든 자원을 허용하겠다는 뜻이 된다.</p>\n<p>이렇게 Spring Security 와 JWT의 설정을 끝냈다. 이제 UserServiceImpl, LoginServiceImpl의 비지니스 로직에서 password를 어떻게 암호화할 수 있는지 알아보자.</p>\n<hr/>\n<h2>서비스 로직</h2>\n<h3>회원가입 프로세스</h3>\n<p><img src=\"https://user-images.githubusercontent.com/59427983/106987685-5c479700-67b1-11eb-8937-3507056b0b22.jpeg\" alt=\"회원가입 로그인 프로세스 001\"></p>\n<ol>\n<li>front에서 회원가입 시 이미 회원가입이 된 ID인지 검사하는 Http Call을 날린다. MySQL에서 회원 ID를 SELECT, 가입 가능한지 판별하여 return. 보면 Spring Security config 파일에 .antMatchers(“/api/user/valid/**“).permitAll() 로 프론트에서 header를 가지고 들어오지 않아도 리소스를 요청할 수 있도록 풀어주었기 때문에 가능하다.</li>\n<li>가입 가능하다면 나머지 정보를 입력해서 Create Http Call을 날림. 여기도 마찬가지로 permitAll()로 풀어둔 상태다.</li>\n<li>Spring Security에서 제공하는 PasswordEncoder를 통해 <code>.encode()</code>메서드로 BCrypt 방식으로 인코딩 후 INSERT</li>\n</ol>\n<h3>로그인 프로세스</h3>\n<p><img src=\"https://user-images.githubusercontent.com/59427983/106987714-68cbef80-67b1-11eb-98d2-17faa2b688c3.jpeg\" alt=\"회원가입 로그인 프로세스 002\"></p>\n<ol>\n<li>로그인 시 ID, Password는 GET 방식으로 날릴 시 url 파라미터에 노출되므로 POST 방식으로 접근.</li>\n<li>Payload에 담긴 ID로 유저 정보 조회</li>\n<li>회원가입 시 사용했던 SpringSecurity의 PasswoardEncoder에서 <code>.matches()</code> 메서드로 유저가 보낸 password와 DB에 BCrypt 방식으로 인코딩된 password를 가져와서 비교함.</li>\n<li>통과 된다면, JwtTokenProvider의 createToken으로 token 생성.</li>\n<li>토큰과 유저정보를 가지고 리턴.</li>\n</ol>\n<p>핵심은 PasswordEncoder다.</p>\n<br/>\n<h4>PasswordEncoder(BCrypt)</h4>\n<p>2가지 메서드를 사용했다.</p>\n<ul>\n<li>.encode(String password) : BCrypt 방식으로 String password를 인코딩해준다.</li>\n<li>.matches(String requestPassword, String DBSavedPassword) : 파라미터로 유저가 요청한 password를 첫번째로 넣어주고, DB에서 조회해온 BCrypt 방식으로 가져온 password와 같은지 내부적으로 판단해 boolean 값으로 리턴해준다. <code>순서가 중요</code>하다. 첫번째 파라미터와 두번째 파라미터를 반대로 적으면 체크가 제대로 되지 않는다.</li>\n</ul>\n<img width=\"408\" alt=\"스크린샷 2021-02-05 오후 12 49 05\" src=\"https://user-images.githubusercontent.com/59427983/106990185-1c83ae00-67b7-11eb-8ce3-6dc6a9df66dd.png\">\n<p>DB에 접속해서 select 해보면 이런 값이 들어가있는 것을 확인할 수 있다. 지금 위의 값은 내가 임의로 만든 사용자인데 모두 <em>같은 비밀번호</em>를 입력했음에도 불구하고 서로 다른 값이 들어가있는 것을 볼 수 있다. 이는 DBA도 유저가 <strong>어떤 패스워드를 사용했는지 모르게</strong> 한다.</p>\n<p>내부 소스를 보자. Service 단 소스다.</p>\n<h3>회원가입</h3>\n<deckgo-highlight-code java  terminal=\"carbon\" theme=\"material\"  highlight-lines=\"\">\n          <code slot=\"code\">@Transactional\n@Override\npublic ResponseEntity&lt;Message&gt; createUser(UserApiRequest request) {\n    if (userIdValid(request.getId())) {\n\n        // 소셜 로그인 패스워드 만들기\n        if (!StringUtils.isEmpty(request.getSocial())) {\n            PasswordUtil pw = new PasswordUtil();\n            String newPw = pw.encryptSHA256(request.getId());\n            request.setPassword(newPw);\n        }\n\n        String encodePassword = passwordEncoder.encode(request.getPassword()); // 이곳\n        request.setPassword(encodePassword);\n\n        userDao.createUser(request);\n\n        headers.setContentType(new MediaType(&quot;application&quot;, &quot;json&quot;, Charset.forName(&quot;UTF-8&quot;)));\n        message.setStatus(StatusEnum.OK);\n        message.setMessage(ResponseMessage.CREATED_USER);\n        message.setData(request);\n\n        return new ResponseEntity &lt;&gt; (message, headers, HttpStatus.OK);\n    } else {\n        message.setStatus(StatusEnum.BAD_REQUEST);\n        message.setMessage(ResponseMessage.ALREADY_USE);\n        return new ResponseEntity &lt;&gt; (message, headers, HttpStatus.NOT_FOUND);\n    }\n}</code>\n        </deckgo-highlight-code>\n<h3>로그인</h3>\n<deckgo-highlight-code java  terminal=\"carbon\" theme=\"material\"  highlight-lines=\"\">\n          <code slot=\"code\">@Override\npublic ResponseEntity&lt;Message&gt; login(LoginApiRequest request) {\n    User user = userDao.readUser(request.getId());\n    if (!ObjectUtils.isEmpty(user)) {\n\n        boolean check = passwordEncoder.matches(request.getPassword(), user.getPassword());\n        if (check) { // 유저가 보유한 패스워드와 입력받은 패스워드가 일치하는 지 확인한다.\n            log.info(&quot;로그인 성공&quot;);\n\n            List &lt;String&gt; roles = new ArrayList &lt;&gt; ();\n            roles.add(&quot;ROLE_USER&quot;);\n\n            String token = jwtTokenProvider.createToken(user.getId(), roles); // id, role 정보만 가지고 token을 만든다.\n            LoginApiResponse response = new LoginApiResponse(\n                token, user.getId(), user.getEmail(), user.getName(), user.getPicture(), user.getBio(), user.getRecentBoard(), user.getInvitedBoard(),\n                user.getCreatedAt(), user.getCreatedBy(), user.getUpdatedAt(), user.getUpdatedBy()\n            );\n\n            headers.setContentType(new MediaType(&quot;application&quot;, &quot;json&quot;, Charset.forName(&quot;UTF-8&quot;)));\n            message.setStatus(StatusEnum.OK);\n            message.setMessage(ResponseMessage.LOGIN_SUCCESS);\n            message.setData(response);\n\n            return new ResponseEntity &lt;&gt; (message, headers, HttpStatus.OK);\n        } else {\n            log.info(&quot;비번이 틀립니다&quot;);\n            message.setStatus(StatusEnum.NOT_FOUND);\n            message.setMessage(ResponseMessage.PASSWORD_WRONG);\n            return new ResponseEntity &lt;&gt; (message, headers, HttpStatus.FORBIDDEN); // 403\n        }\n    } else {\n        log.info(&quot;해당 id가 없습니다.&quot;);\n        message.setStatus(StatusEnum.NOT_FOUND);\n        message.setMessage(ResponseMessage.NOT_FOUND_USER);\n        return new ResponseEntity &lt;&gt; (message, headers, HttpStatus.FORBIDDEN); // 403\n    }\n}</code>\n        </deckgo-highlight-code>\n<p>참고자료 : <a href=\"https://mia-dahae.tistory.com/120\">https://mia-dahae.tistory.com/120</a></p>\n<br/>\n<p>여기까지가 SpringBoot의 내부 처리 로직이다. 회원가입과 로그인 로직이 완성되었으므로 vue에서 어떻게 이것을 표현할지 다음 포스팅에서 알아보자. 소셜 로그인까지 같이.</p>\n<hr/>\n<blockquote>\n<p>프로젝트 구경하기 -> <a href=\"https://tripllo.tech\">Tripllo_메인</a>, <a href=\"https://github.com/pozafly/tripllo_vue\">Vue_Github</a>, <a href=\"https://github.com/pozafly/tripllo_springBoot\">SpringBoot_Github</a></p>\n</blockquote>","htmlAst":{"type":"root","children":[{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"Spring Security와 JWT를 사용해서 로그인 기능을 구현했다. Spring Security의 구현된 소스와 login의 Service 단 내부 로직을 개념에 맞춰서 알아보자."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이제 실제적으로 SpringBoot부터 구현하자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Dependency 등록"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"첫번째로, build.gradle에 dependencies를 추가해주자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"deckgo-highlight-code","properties":{"terminal":"carbon","theme":"material","highlight-lines":"undefined"},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"implementation 'org.springframework.boot:spring-boot-starter-security'\nimplementation 'io.jsonwebtoken:jjwt:0.9.1'"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"Common 세팅"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"common이란 패키지 밑에 security 패키지를 만들었다. 이곳에 이제 Security 관련 class들이 들어갈 예정이다. 그 밑에 UserService 관련 객체가 들어갈 securityUser 패키지를 만들고 Spring Security의 전체 구조 사진의 5,6,7 번에 해당하는 UserDetailsService, UserDetail을 구현한 클래스를 만들었다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"SecurityUser"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"deckgo-highlight-code","properties":{"java":"","terminal":"carbon","theme":"material","highlight-lines":""},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"package com.pozafly.tripllo.common.security.securityUser;\n\nimport com.pozafly.tripllo.user.model.User;   // security 외에 Tripllo에서 직접 사용하는 User class\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\n\npublic class SecurityUser implements UserDetails {\n\n    private Collection<? extends GrantedAuthority> authorities;\n    private User user;   // 이곳에 Tripllo의 User 객체를 넣어준다.\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() { return authorities; }\n    @Override\n    public String getPassword() { return user.getPassword(); }     // 패스워드를 들고오는 부분\n    @Override\n    public String getUsername() { return user.getId(); }   // id를 들고오는 부분\n    @Override\n    public boolean isAccountNonExpired() { return true; }\n    @Override\n    public boolean isAccountNonLocked() { return true; }\n    @Override\n    public boolean isCredentialsNonExpired() { return true; }\n    @Override\n    public boolean isEnabled() { return true; }\n}"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"UserDetails를 구현한 class이다. UserDetails는 SpringSecurity의 인터페이스이고, 우리 프로젝트에서 만든 인터페이스가 아니다. Tripllo에서 사용하는 객체는 User 하나다. 제일 위 사진을 보면 6번에 해당하는 UserDetails 를 구현체로 한 구현 class가 해당 class이며 이는 Tripllo에서 실제로 사용하는 User 객체의 id, pw를 사용하는 모습을 볼 수 있다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"UserDetailsService"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"deckgo-highlight-code","properties":{"java":"","terminal":"carbon","theme":"material","highlight-lines":""},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"package com.pozafly.tripllo.common.security.securityUser;\n\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\n\npublic interface UserDetailsService {\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;\n}"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"다음으로 볼 것은 위 그림에 5,6,7 번이 모두 물려있는 UserDetailService다. 이 인터페이스는 구현체인 UserDetailServiceImpl에서 이어지는데 하나의 메서드만 가지고 있다. "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"loadUserByUsername()"}]},{"type":"text","value":". 이 메서드 또한 SpringSecurity에서 자체적으로 제공하는 메서드인데 매개변수로 String username이 들어간다. 이름에서 알 수 있듯, username이라는 구분 값으로 DB에 접속해서 user의 정보를 가져오는 메서드."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"UserDetailServiceImpl"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"deckgo-highlight-code","properties":{"java":"","terminal":"carbon","theme":"material","highlight-lines":""},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"package com.pozafly.tripllo.common.security.securityUser;\n\nimport com.pozafly.tripllo.user.dao.UserDao;\nimport com.pozafly.tripllo.user.model.User;\nimport lombok.extern.log4j.Log4j2;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\n@Log4j2\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    @Autowired\n    private UserDao userDao;   // Tripllo 유저 조회하기 위해 DI\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        // 로그인 시도하려는 유저정보 조회\n        log.info(\"security loadUserByUsername에서 유저 조회\");\n        User user = userDao.readUser(username);   // tripllo에서 사용하는 User 조회 메서드\n\n        // 조회가 되지않는 User는 에러발생.\n        if(user == null){ throw new UsernameNotFoundException(username); }\n\n        // 조회한 정보를 userCustom에 담는다.\n        // 만약 파라미터를 추가해야한다면 UserCustom 을 먼저 수정한다.\n        return new SecurityUser() {\n            @Override\n            public Collection<? extends GrantedAuthority> getAuthorities() {\n                List<GrantedAuthority> authorities = new ArrayList<GrantedAuthority>();\n                authorities.add(new SimpleGrantedAuthority(user.getRole()));  // Role을 위해\n                return authorities;\n            }\n            @Override\n            public String getPassword() { return user.getPassword(); }\n            @Override\n            public String getUsername() { return user.getId(); }\n            @Override\n            public boolean isAccountNonExpired() { return true; }\n            @Override\n            public boolean isAccountNonLocked() { return true; }\n            @Override\n            public boolean isCredentialsNonExpired() { return true; }\n            @Override\n            public boolean isEnabled() { return true; }\n        };\n    }\n}"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"구현체인 UserServiceImpl 에서는 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"loadUserByUsername()"}]},{"type":"text","value":"를 정의해준다. Tripllo에서 사용하는 user를 조회하는 Dao를 DI해서 MyBatis로 연결되어 유저 정보를 조회해서 가져오고, username에는 user.getId(), password에는 user.getId()를 사용해서 넣어주었다. Role에 대해서는 밑에서 설명 예정."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"JwtTokenProvider"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"deckgo-highlight-code","properties":{"java":"","terminal":"carbon","theme":"material","highlight-lines":""},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"package com.pozafly.tripllo.common.security;\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.Jws;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.PostConstruct;\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.Base64;\nimport java.util.Date;\nimport java.util.List;\n\n@RequiredArgsConstructor\n@Component\npublic class JwtTokenProvider {\n\n    private static String secretKey = \"triplloApplication\";\n\n    // 토큰 유효시간 60분 * 24 = 24시간\n    private long tokenValidTime = 60 * 60 * 24 * 1000L;\n\n    private final UserDetailsService userDetailsService;\n\n    // 객체 초기화, secretKey를 Base64로 인코딩한다.\n    @PostConstruct\n    protected void init() {\n        secretKey = Base64.getEncoder().encodeToString(secretKey.getBytes());\n    }\n\n    // JWT 토큰 생성\n    public String createToken(String userPk, List<String> roles) {\n        Claims claims = Jwts.claims().setSubject(userPk); // JWT payload 에 저장되는 정보단위\n        claims.put(\"roles\", roles); // 정보는 key / value 쌍으로 저장된다.\n        Date now = new Date();\n        return Jwts.builder()\n                .setClaims(claims) // 정보 저장\n                .setIssuedAt(now) // 토큰 발행 시간 정보\n                .setExpiration(new Date(now.getTime() + tokenValidTime)) // set Expire Time\n                .signWith(SignatureAlgorithm.HS256, secretKey)  // 사용할 암호화 알고리즘, signature 에 들어갈 secret값 세팅\n                .compact();\n    }\n\n    // JWT 토큰에서 인증 정보 조회\n    public Authentication getAuthentication(String token) {\n        UserDetails userDetails = userDetailsService.loadUserByUsername(this.getUserPk(token));\n        return new UsernamePasswordAuthenticationToken(userDetails, \"\", userDetails.getAuthorities());\n    }\n\n    // 토큰에서 회원 정보 추출\n    public String getUserPk(String token) {\n        return Jwts.parser().setSigningKey(secretKey).parseClaimsJws(token).getBody().getSubject();\n    }\n\n    // Request의 Header에서 token 값을 가져옴. \"Authorization\" : \"TOKEN값'\n    public String resolveToken(HttpServletRequest request) {\n        return request.getHeader(\"Authorization\");\n    }\n\n    // 토큰의 유효성 + 만료일자 확인\n    public boolean validateToken(String jwtToken) {\n        try {\n            Jws<Claims> claims = Jwts.parser().setSigningKey(secretKey).parseClaimsJws(jwtToken);\n            return !claims.getBody().getExpiration().before(new Date());\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"위의 사진에 4,5,7,8번이 물려있는 AuthenticationProviders의 하나인 JwtTokenProvider를 만들어주었다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"init() : 상단의 secretKey 상수에 물려있는 String 값을 기반으로 Base64 로 인코딩해서 토큰을 생성한다. 물론 이 부분은 application.properties나 application.yml로 빼서 @Value 로 받아와 사용하는것이 좋겠다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"createToken() : userPK(가령 id)와 role list를 매개변수로 받아 Claims를 생성하고, role을 Claims에 집어넣난다. Builder 패턴으로 정보, 토큰 발행시간, 토큰 유효시간, 그리고 사용할 알고리즘을 세팅한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"getAuthentication() : 위에서 생성했던 loadUserByUsername() 메서드를 여기서 사용한다. 클라이언트로부터 받은 token을 파싱해서 이름을 추출하고 userDetails를 가져온다. return 객체는 사진 2번에 물려있는 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"UsernamePasswordAuthenticationToken"}]},{"type":"text","value":"이다. 이 녀석이 핵심!"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"getUserPk() : 토큰에서 회원 정보 추출."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"validateToken() : 토큰의 유효성 검사."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"resolveToken() : 이녀석을 유의해서 봐야하는데 이녀석 때문에 몇시간을 헤멘지 모르겠다. 중요한 것은"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"deckgo-highlight-code","properties":{"java":"","terminal":"carbon","theme":"material","highlight-lines":""},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"return request.getHeader(\"Authorization\");"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이 부분이다. vue에서 axios로 api를 날릴때 token 이름을 “Token …” 이런식으로 주었더니 토큰을 가져오지 못하는 경우가 발생했다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"width":1038,"alt":"스크린샷 2021-02-04 오후 9 18 58","src":"https://user-images.githubusercontent.com/59427983/106891971-c79c5500-672e-11eb-8840-2377296e626c.png"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"개발자 도구에 Network 탭에서 확인해보자. 만약 위 코드를"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"deckgo-highlight-code","properties":{"java":"","terminal":"carbon","theme":"material","highlight-lines":""},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"return request.getHeader(\"Token\");"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이라고 했다고 하자. 그럼 클라이언트 단에서 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"Authorization"}]},{"type":"text","value":" 이라는 header 명으로 axios에서 요청을 보냈다. 그러자 Spring Security에서 인증되지 않아 403 인증 오류를 뱉는다. 즉, resolveToken() 메서드의 getHeader(“Authorization”) 이렇게 이름을 맞춰주거나, axios 로 http call을 날릴 때 헤더명을 “Token” 으로 맞춰주거나 해야 한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"JwtAuthenticationFilter"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"deckgo-highlight-code","properties":{"java":"","terminal":"carbon","theme":"material","highlight-lines":""},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"package com.pozafly.tripllo.common.security;\n\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.web.filter.GenericFilterBean;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\n@RequiredArgsConstructor\npublic class JwtAuthenticationFilter extends GenericFilterBean {\n\n    private final JwtTokenProvider jwtTokenProvider;\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        // 헤더에서 JWT 를 받아옴.\n        String token = jwtTokenProvider.resolveToken((HttpServletRequest) request);\n\n        // 유효한 토큰인지 확인함.\n        if (token != null && jwtTokenProvider.validateToken(token)) {\n            // 토큰이 유효하면 토큰으로부터 유저 정보를 받아옴.\n            Authentication authentication = jwtTokenProvider.getAuthentication(token);\n            // SecurityContext 에 Authentication 객체를 저장함.\n            SecurityContextHolder.getContext().setAuthentication(authentication);\n        }\n        chain.doFilter(request, response);\n    }\n}"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이번엔 클라이언트에서 가장 먼저 접근했을 때 들어오는 Filter인, "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"JwtAuthenticationFilter"}]},{"type":"text","value":" 를 살펴보자. 모든 filter는 요청이 들어왔을 때 doFilter() 메서드가 실행되며, 마칠 때 다른 filter 가 있다면 chain을 걸어주어야 한다. Provider에서 토큰을 받아오고, 다시 Provider에서 검증하는 과정을 거친다. 이제 마지막 부분인 config 부분을 보자. 이때까지 setting 이었다면, 이번에는 실질적으로 이 config 파일에서 모든 설정을 해줄 수 있다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"deckgo-highlight-code","properties":{"java":"","terminal":"carbon","theme":"material","highlight-lines":""},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"package com.pozafly.tripllo.common.security;\n\nimport com.google.common.collect.ImmutableList;\nimport lombok.RequiredArgsConstructor;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.HttpMethod;\nimport org.springframework.security.authentication.AuthenticationManager;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.factory.PasswordEncoderFactories;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\nimport org.springframework.web.cors.CorsConfiguration;\nimport org.springframework.web.cors.CorsConfigurationSource;\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\n\n@Configuration\n@RequiredArgsConstructor\n@EnableWebSecurity\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    private final JwtTokenProvider jwtTokenProvider;\n\n    // 암호화에 필요한 PasswordEncoder를 Bean으로 등록함.\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    // authenticationManager를 Bean 등록함.\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    // 여기는 CORS 설정임.\n    @Bean\n    public CorsConfigurationSource corsConfigurationSource() {\n      final CorsConfiguration configuration = new CorsConfiguration();\n      configuration.setAllowedOrigins(ImmutableList.of(\"http://localhost:8080\", \"http://tripllo.tech.s3-website.ap-northeast-2.amazonaws.com\", \"http://tripllo.tech\", \"https://tripllo.tech\"));\n      configuration.setAllowedMethods(ImmutableList.of(\"HEAD\",\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\"));\n      configuration.setAllowCredentials(true);\n      // 토큰을 Authorization 이라는 이름으로 받겠다.\n      configuration.setAllowedHeaders(ImmutableList.of(\"Authorization\", \"Cache-Control\", \"Content-Type\"));\n      final UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\n      source.registerCorsConfiguration(\"/**\", configuration);\n      return source;\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n          .httpBasic().disable() // rest api 만을 고려하여 기본 설정은 해제.\n          .csrf().disable() // csrf 보안 토큰 disable처리.\n          .formLogin().disable() //기본 로그인 페이지 없애기\n          .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS) // 토큰 기반 인증이므로 세션 역시 사용하지 않음.\n          .and()\n            .authorizeRequests() // 요청에 대한 사용권한 체크\n            //                .antMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n            .antMatchers(\"/profile\").permitAll()\n            .antMatchers(\"/websocket/**\").permitAll()\n            // post 방식의 user create(회원가입)은 허용한다.\n            .antMatchers(HttpMethod.POST, \"/api/user\").permitAll()\n            // 회원가입 전 사용하고 싶은 회원 id를 validation 해볼 수 있는 api도 open\n            .antMatchers(\"/api/user/valid/**\").permitAll()\n            // 로그인 오픈\n            .antMatchers(\"/api/login/**\").permitAll()\n            .antMatchers(\"/api/logout\").permitAll()\n            .antMatchers(\"/api/email/**\").permitAll()\n\n            // 인증된 사용자만 가능하다(즉, 헤더에 토큰을 준 사람만이 가능한 것임.)\n            .antMatchers(\"/api/**\").authenticated()\n            // role이 ROLE_USER 인 역할만 통과\n            .antMatchers(\"/api/**\").hasRole(\"USER\")\n            .anyRequest().authenticated()   // 그외 나머지 요청은 인증 가능 해야한다.\n          .and()\n\t          .cors()\n          .and()\n          \t.addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider),\n                             \tUsernamePasswordAuthenticationFilter.class)\n        // JwtAuthenticationFilter를 UsernamePasswordAuthenticationFilter 전에 넣는다\n                ;\n    }\n}"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"하나씩 천천히 들여다보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"JwtTokenProvider를 마찬가지로 DI 받아서 사용한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Spring Security라이브러리에서 제공하는 BCryptPasswordEncoder를 사용한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"사진의 3,4,8,9에 물려있는 AuthenticationManager를 Bean으로 등록해준다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"corsConfigurationSource 는 cors 설정이다. cors는 제작기를 따로 만들어서 다룰 예정이지만 가볍게 짚고 넘어가보자. cors란, 서로 다른 도메인 간 api response를 막는걸 말한다. 쉽게 말해 vue는 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"8080"}]},{"type":"text","value":" 포트를 사용하고, SpringBoot는 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"3000"}]},{"type":"text","value":"포트를 사용하는데 포트가 다르기 때문에 리소스를 막아주는 역할을 한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"SpringSecurity를 도입하기 전에는 WebMvcConfigurer를 상속받은 CorsConfig class를 따로 만들어서 해결했지만, 여기서 cors 설정을 해주면 CorsConfig 가 무시되므로 여기서 보면된다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"setAllowedOrigins() : url에 해당하는 출처를 허가하겠다라는 뜻이다. ImmutableList.of() 안에 허용하고 싶은 도메인들을 String 형식으로 적어주면 된다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"setAllowedMethods() : 허용하고 싶은 http 메서드를 마찬가지로 적어준다. 가령 “GET”, “POST”, “PUT”, “DELETE”, “OPTIONS” 같은 메서드들."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"setAllowCredentials() : true일 때, header가 없는 응답들은 거르겠다는 뜻이다. header가 있어야 함을 의미."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"addAllowedHeaders() : 어떤 이름으로 된 헤더들을 허용하겠느냐? ※addAllowedHeader(”*”) 로 모든 헤더 허용 가능."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"그리고 모든 설정한 configuration을 등록해준다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"configure 메서드에서 SpringSecurity 설정을 해줄 수 있다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"httpBasic().disable() : rest api 이므로 기본설정 사용안함. 기본설정은 비인증시 로그인폼 화면으로 리다이렉트 됨.(vue를 사용할 것이므로.)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":".csrf().disable() : 마찬가지로 rest api이므로 csrf 보안이 필요없으므로 disable처리."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"STATELESS 란 무상태성, 비보존한다는 뜻이다. 마찬가지로, 우리는 토큰 기반으로 인증을 계속 할것이기 때문에 세션이 필요없으므로 STATELESS를 사용한다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"★위 3가지가 중요하다. react 나 vue 같이 서버단에서 화면을 보여주는것이 아니라 따로 존재하는 프론트 단에서는 위 설정이 필요없기 때문이다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"antMatchers() 는 http 메서드와 url을 적어줄 수 있는데 controller에서 접근하는 url을 말한다. 뒤에 따라오는 .permitAll()은 모두 허용하겠다는 뜻이된다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":".antMatchers(“/api/**“).authenticated() 이 부분은 헤더에 토큰은 준 user만 허락한다는 뜻이 된다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":".antMatchers(“/api/**“).hasRole(“USER”) : 이부분은 role에 대한 부분이다. role이 밑에서 설명하겠다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"그리고 마지막으로 우리가 만들어준 JwtAuthenticationFilter 와 사용하는 UsernamePasswordAuthenticationFilter 를 등록하고 마친다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"참고자료 : "},{"type":"element","tagName":"a","properties":{"href":"https://dongdd.tistory.com/175"},"children":[{"type":"text","value":"https://dongdd.tistory.com/175"}]},{"type":"text","value":", "},{"type":"element","tagName":"a","properties":{"href":"https://postitforhooney.tistory.com/entry/SpringSecurity-%EC%B4%88%EB%B3%B4%EC%9E%90%EA%B0%80-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-Spring-Security-%ED%8D%BC%EC%98%B4"},"children":[{"type":"text","value":"https://postitforhooney.tistory.com/entry/SpringSecurity-%EC%B4%88%EB%B3%B4%EC%9E%90%EA%B0%80-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-Spring-Security-%ED%8D%BC%EC%98%B4"}]},{"type":"text","value":", "},{"type":"element","tagName":"a","properties":{"href":"https://velog.io/@tlatldms/Spring-boot-Spring-security-JWT-Redis-mySQL-2%ED%8E%B8"},"children":[{"type":"text","value":"https://velog.io/@tlatldms/Spring-boot-Spring-security-JWT-Redis-mySQL-2%ED%8E%B8"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"Role에 대해서"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"role이란, "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"역할"}]},{"type":"text","value":"을 말한다. Workbench의 user 테이블을 보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"width":94,"alt":"스크린샷 2021-02-04 오후 10 22 33","src":"https://user-images.githubusercontent.com/59427983/106898417-80669200-6737-11eb-8387-4860cadc36e2.png"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이렇게 role이라는 column이 있고 ROLE"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"USER라는 값이 String으로 들어있다. spring security의 config 파일에 보면 .antMatchers(“/api/\\"}]},{"type":"text","value":"*“).hasRole(“USER”) 이렇게 되어있다. role을 config에 등록해서, 어떤 api 호출이 가능한지 분기를 태울 수 있다는 말이된다. 그리고 hasRole에 USER 라는 값이 있으면 prefix 로 자동으로 앞에 **ROLE"},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"\\"}]},{"type":"text","value":"* 이라는 값을 붙여서 검증한다. 즉, 일반 유저라는 뜻이 되는 것이고, 만약 user 테이블에 ROLE_ADMIN 의 값을 주고 .antMatchers(“/api/**“).hasRole(“ADMIN”) 이렇게 하면 api에 해당하는 모든 자원을 허용하겠다는 뜻이 된다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"이렇게 Spring Security 와 JWT의 설정을 끝냈다. 이제 UserServiceImpl, LoginServiceImpl의 비지니스 로직에서 password를 어떻게 암호화할 수 있는지 알아보자."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h2","properties":{},"children":[{"type":"text","value":"서비스 로직"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"회원가입 프로세스"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/59427983/106987685-5c479700-67b1-11eb-8937-3507056b0b22.jpeg","alt":"회원가입 로그인 프로세스 001"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"front에서 회원가입 시 이미 회원가입이 된 ID인지 검사하는 Http Call을 날린다. MySQL에서 회원 ID를 SELECT, 가입 가능한지 판별하여 return. 보면 Spring Security config 파일에 .antMatchers(“/api/user/valid/**“).permitAll() 로 프론트에서 header를 가지고 들어오지 않아도 리소스를 요청할 수 있도록 풀어주었기 때문에 가능하다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"가입 가능하다면 나머지 정보를 입력해서 Create Http Call을 날림. 여기도 마찬가지로 permitAll()로 풀어둔 상태다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Spring Security에서 제공하는 PasswordEncoder를 통해 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":".encode()"}]},{"type":"text","value":"메서드로 BCrypt 방식으로 인코딩 후 INSERT"}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"로그인 프로세스"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"element","tagName":"img","properties":{"src":"https://user-images.githubusercontent.com/59427983/106987714-68cbef80-67b1-11eb-98d2-17faa2b688c3.jpeg","alt":"회원가입 로그인 프로세스 002"},"children":[]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ol","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"로그인 시 ID, Password는 GET 방식으로 날릴 시 url 파라미터에 노출되므로 POST 방식으로 접근."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"Payload에 담긴 ID로 유저 정보 조회"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"회원가입 시 사용했던 SpringSecurity의 PasswoardEncoder에서 "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":".matches()"}]},{"type":"text","value":" 메서드로 유저가 보낸 password와 DB에 BCrypt 방식으로 인코딩된 password를 가져와서 비교함."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"통과 된다면, JwtTokenProvider의 createToken으로 token 생성."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":"토큰과 유저정보를 가지고 리턴."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"핵심은 PasswordEncoder다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"h4","properties":{},"children":[{"type":"text","value":"PasswordEncoder(BCrypt)"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"2가지 메서드를 사용했다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"ul","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":".encode(String password) : BCrypt 방식으로 String password를 인코딩해준다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"li","properties":{},"children":[{"type":"text","value":".matches(String requestPassword, String DBSavedPassword) : 파라미터로 유저가 요청한 password를 첫번째로 넣어주고, DB에서 조회해온 BCrypt 방식으로 가져온 password와 같은지 내부적으로 판단해 boolean 값으로 리턴해준다. "},{"type":"element","tagName":"code","properties":{},"children":[{"type":"text","value":"순서가 중요"}]},{"type":"text","value":"하다. 첫번째 파라미터와 두번째 파라미터를 반대로 적으면 체크가 제대로 되지 않는다."}]},{"type":"text","value":"\n"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"img","properties":{"width":408,"alt":"스크린샷 2021-02-05 오후 12 49 05","src":"https://user-images.githubusercontent.com/59427983/106990185-1c83ae00-67b7-11eb-8ce3-6dc6a9df66dd.png"},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"DB에 접속해서 select 해보면 이런 값이 들어가있는 것을 확인할 수 있다. 지금 위의 값은 내가 임의로 만든 사용자인데 모두 "},{"type":"element","tagName":"em","properties":{},"children":[{"type":"text","value":"같은 비밀번호"}]},{"type":"text","value":"를 입력했음에도 불구하고 서로 다른 값이 들어가있는 것을 볼 수 있다. 이는 DBA도 유저가 "},{"type":"element","tagName":"strong","properties":{},"children":[{"type":"text","value":"어떤 패스워드를 사용했는지 모르게"}]},{"type":"text","value":" 한다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"내부 소스를 보자. Service 단 소스다."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"회원가입"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"deckgo-highlight-code","properties":{"java":"","terminal":"carbon","theme":"material","highlight-lines":""},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"@Transactional\n@Override\npublic ResponseEntity<Message> createUser(UserApiRequest request) {\n    if (userIdValid(request.getId())) {\n\n        // 소셜 로그인 패스워드 만들기\n        if (!StringUtils.isEmpty(request.getSocial())) {\n            PasswordUtil pw = new PasswordUtil();\n            String newPw = pw.encryptSHA256(request.getId());\n            request.setPassword(newPw);\n        }\n\n        String encodePassword = passwordEncoder.encode(request.getPassword()); // 이곳\n        request.setPassword(encodePassword);\n\n        userDao.createUser(request);\n\n        headers.setContentType(new MediaType(\"application\", \"json\", Charset.forName(\"UTF-8\")));\n        message.setStatus(StatusEnum.OK);\n        message.setMessage(ResponseMessage.CREATED_USER);\n        message.setData(request);\n\n        return new ResponseEntity <> (message, headers, HttpStatus.OK);\n    } else {\n        message.setStatus(StatusEnum.BAD_REQUEST);\n        message.setMessage(ResponseMessage.ALREADY_USE);\n        return new ResponseEntity <> (message, headers, HttpStatus.NOT_FOUND);\n    }\n}"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"h3","properties":{},"children":[{"type":"text","value":"로그인"}]},{"type":"text","value":"\n"},{"type":"element","tagName":"deckgo-highlight-code","properties":{"java":"","terminal":"carbon","theme":"material","highlight-lines":""},"children":[{"type":"text","value":"\n          "},{"type":"element","tagName":"code","properties":{"slot":"code"},"children":[{"type":"text","value":"@Override\npublic ResponseEntity<Message> login(LoginApiRequest request) {\n    User user = userDao.readUser(request.getId());\n    if (!ObjectUtils.isEmpty(user)) {\n\n        boolean check = passwordEncoder.matches(request.getPassword(), user.getPassword());\n        if (check) { // 유저가 보유한 패스워드와 입력받은 패스워드가 일치하는 지 확인한다.\n            log.info(\"로그인 성공\");\n\n            List <String> roles = new ArrayList <> ();\n            roles.add(\"ROLE_USER\");\n\n            String token = jwtTokenProvider.createToken(user.getId(), roles); // id, role 정보만 가지고 token을 만든다.\n            LoginApiResponse response = new LoginApiResponse(\n                token, user.getId(), user.getEmail(), user.getName(), user.getPicture(), user.getBio(), user.getRecentBoard(), user.getInvitedBoard(),\n                user.getCreatedAt(), user.getCreatedBy(), user.getUpdatedAt(), user.getUpdatedBy()\n            );\n\n            headers.setContentType(new MediaType(\"application\", \"json\", Charset.forName(\"UTF-8\")));\n            message.setStatus(StatusEnum.OK);\n            message.setMessage(ResponseMessage.LOGIN_SUCCESS);\n            message.setData(response);\n\n            return new ResponseEntity <> (message, headers, HttpStatus.OK);\n        } else {\n            log.info(\"비번이 틀립니다\");\n            message.setStatus(StatusEnum.NOT_FOUND);\n            message.setMessage(ResponseMessage.PASSWORD_WRONG);\n            return new ResponseEntity <> (message, headers, HttpStatus.FORBIDDEN); // 403\n        }\n    } else {\n        log.info(\"해당 id가 없습니다.\");\n        message.setStatus(StatusEnum.NOT_FOUND);\n        message.setMessage(ResponseMessage.NOT_FOUND_USER);\n        return new ResponseEntity <> (message, headers, HttpStatus.FORBIDDEN); // 403\n    }\n}"}]},{"type":"text","value":"\n        "}]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"참고자료 : "},{"type":"element","tagName":"a","properties":{"href":"https://mia-dahae.tistory.com/120"},"children":[{"type":"text","value":"https://mia-dahae.tistory.com/120"}]}]},{"type":"text","value":"\n"},{"type":"element","tagName":"br","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"여기까지가 SpringBoot의 내부 처리 로직이다. 회원가입과 로그인 로직이 완성되었으므로 vue에서 어떻게 이것을 표현할지 다음 포스팅에서 알아보자. 소셜 로그인까지 같이."}]},{"type":"text","value":"\n"},{"type":"element","tagName":"hr","properties":{},"children":[]},{"type":"text","value":"\n"},{"type":"element","tagName":"blockquote","properties":{},"children":[{"type":"text","value":"\n"},{"type":"element","tagName":"p","properties":{},"children":[{"type":"text","value":"프로젝트 구경하기 -> "},{"type":"element","tagName":"a","properties":{"href":"https://tripllo.tech"},"children":[{"type":"text","value":"Tripllo_메인"}]},{"type":"text","value":", "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/pozafly/tripllo_vue"},"children":[{"type":"text","value":"Vue_Github"}]},{"type":"text","value":", "},{"type":"element","tagName":"a","properties":{"href":"https://github.com/pozafly/tripllo_springBoot"},"children":[{"type":"text","value":"SpringBoot_Github"}]}]},{"type":"text","value":"\n"}]}],"data":{"quirksMode":false}},"excerpt":"Spring Security와 JWT를 사용해서 로그인 기능을 구현했다. Spring Security의 구현된 소스와 login의 Service 단 내부 로직을 개념에 맞춰서 알아보자. 이제 실제적으로 SpringBoot…","timeToRead":13,"frontmatter":{"title":"(5) 로그인2 -SpringBoot 구현","userDate":"4 February 2021","date":"2021-02-04T15:03:47.149Z","tags":["Tripllo 제작기"],"excerpt":"Spring Security와 JWT를 사용해서 로그인 기능을 구현했다. Spring Security의 구현된 소스와 login의 Service 단 내부 로직을 개념에 맞춰서 알아보자.","image":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD2ElEQVQ4y31TS2wbVRS9YyeoTZxQyY1jYZIGBZFilQYhVBbZIKRAsyBCCmLPColFF0VILLqqIFkgFNEsQCJJUyBJa1LHsT0z/s3Yjj0z9ng8H3vs8Sf2NBWx01TBhdKiNqUPjasgJChHejpP912dd8+79wH8A4F0EcMZBQguf4ySanO0rC/RUn2BkuqLlFRfoGX9e0qsfeVP5i1+Jg9BvgT/grWvv82z86sQFirmEK8CzuasbirzrTehLPkSucveTeXKRlxe8jP5ZT+Tn3XTgiUk1IDkVHMoo5mCfNFkMMmpGFiP29qC8y4CSK4IzUcIEEIg6C34KZyC9WgWrlM8XI/w4KYFILgCnPvsIsxf80KILwIlViCSLUMkW4FAugBgsz/XCQCd05e+6w8L5bfddOasm+YnV/D4AACYl/2x11fJxPurZOLdZTw+5U3IbxrxrxdX7AQrT5CcMk5wyjjJKWf9SXkArH02w/PQzNziJCXVt0OZSj0i1lrehDJlVBoWqrNkSttf9sdrvmTuVrLY8AIANu/yTRCsivxM7gHOqn8QbAERrPoNfPjx+baVIF9uWzWSdx6iw735LkJApp6cHcaGhkdMp0Zf7aDlG4OX3ZGTnpg8vLROOQlO6wdXKN1JS/orOKOe9jPq6NyVtTcIrjDKlHad9xDCSK54JMiXvyS4woovobg9MfEtN51pi/O1VruAw4sajxDAWoR3sKXd+75EDnli4uONuHQQy22jVGVvdz2a7ceZvJlgC9M4oy4E0tpSWNgaY7QGkKkSBNLa+SBfbhFccYuW9GY8f/Md+GGDcqS3bv/OaM3H4Wz1gJb1h4J+B3HlWzvehGIPpEvgiYngCnHtDoeFCtxFyGRUNe8inDirToaF6jgt6xMRccsGq0TiebbUNARQVNZRVNFRurqHGK15D2eLDk9cgrVIemwFj3/qZ/KfuGn+BUNseMTZbTDOqhBTtmFT/RliuW2AawHWypaaPkbbCbGlZoDRGiSjNSKM1ry6HhOPezdl8CVzH10lk5J3U5Y8sexY4wAdNgkjU5qZlnRTPH/TFFV0gEz9DqjNB5DVW1DZ/xPUxn0gOQ248m1Yo0T40RfHcLYI730w1QUAxohZLsxcwoyf8p/o6j7S0W05etrS23XS0nPU2Wez2l8ccfYOv/Ryj2NwCPsNISxV3TPGapOW9BnjLQNpzeQK8fAUHOsEsJwB6D0D2LOvYVjPKQwzDWAYZscwrMPI2EcIImLtRDBTsW39iiCUqcL/4AszwEUHwOcnAKYHAS7Yn8Sf+Tuj8gsCSqy3l9GAqHzjqXJ/AaR/W/9Pzcd6AAAAAElFTkSuQmCC","aspectRatio":1.3333333333333333,"src":"/static/cf052c2134f0abd114c107d149d0dd49/1eab0/tripllo5.png","srcSet":"/static/cf052c2134f0abd114c107d149d0dd49/1eab0/tripllo5.png 820w","sizes":"(max-width: 820px) 100vw, 820px"}}},"author":[{"id":"Pozafly","bio":"Frontend Developer","avatar":{"children":[{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAACY0lEQVQ4y42UTUhUURTHz7kzFiN9aLsSK5JIGV2URREGBX2ppKGUptVMZYJ9OPPemzfjyloXSDsXtRD6oFVUIFGtTHARFoEgSiFkJRFWGBPavHfvP+6rbLIZ9XIWh8P98T/vvP+5FCVkjAgpi5TpJdnuUMZqO7kJQq3v/lHRH9e8XDysDEKEZ1bw+gKuiP0WV4uC28lJCOyky7nlwUDJxv10PcG6uDAcIWkRzvJ4gPKDTweKeu7kUeFFkTS8jhaE3YQPpXQst66qfgbVX7CkonwHxTtEBnGaQ9qMBnq2dOWqksHRAYmHwLpHfbki/7R4bf03uXRYTyXmRyFty0vYpgJcZ9pxww6WhZo2UW2HLzusGxbYTV3+DWu2v50akgAUlOxTKH017s9bfojuxVlfy6xsCOyjrqLu3isAXCk1DTjSBoo6b1bTDetf8TRlHyzCmUocTKqPjvJ0oeWBEUfu+aTatsAkREXGthkxQpWVuj2Z0sIKv470kmvvUzWhlE2IZIQNgXOEq2XKnfZk/8DKU09OqEur1QWCwVng84T+bpX8hs9j+Dr+NybH8D2J3k7VRjB8Wf6zIRALuIZfmjnSyHFNHdLQ4Rh+GQvIKMv5HBYjmHoxlKlXUk/I9IpRkiapWDaHGXolflSKW838IszDzTxYz49DPBzi0Spxt5XfHeeXTTxoppmcZh0SJxzm3rVib1CEN4v2oAiXiZYCsatYNBaLxgPcs1XYR7jPTjPprLJ+NFroQ4Smmvl5Aw/U8IOTPHyCh07xm1aeqOMnYR6x5lkMryVpkbIJcdKemf1s28vnbOVPfGtgRKO972EAAAAASUVORK5CYII=","aspectRatio":1,"src":"/static/8c061761f263c344f2c0416607c8adf1/bc8e0/pozafly.png","srcSet":"/static/8c061761f263c344f2c0416607c8adf1/22f7f/pozafly.png 40w,\n/static/8c061761f263c344f2c0416607c8adf1/587c9/pozafly.png 80w,\n/static/8c061761f263c344f2c0416607c8adf1/d966b/pozafly.png 120w,\n/static/8c061761f263c344f2c0416607c8adf1/bc8e0/pozafly.png 800w,\n/static/8c061761f263c344f2c0416607c8adf1/d4b30/pozafly.png 1242w","sizes":"(max-width: 800px) 100vw, 800px"}}]}}]}},"relatedPosts":{"totalCount":14,"edges":[{"node":{"id":"fe92f8cd-f3c9-50b2-ad3e-5b2147105978","timeToRead":4,"excerpt":"Vuex-store와 EventBus에 대한 고찰  Tripllo 프로젝트를 리팩토링 하면서, vue 리팩토링1의 6.store에 필요없는 state 제거 파트를 진행하게 되었다. 해당 부분을 상세하게 한번 보면서 생각할 부분을 정리해보자. store…","frontmatter":{"title":"(13) Vuex-store와 EventBus에 대한 고찰","date":"2021-04-16T15:13:47.149Z"},"fields":{"slug":"/tripllo/(13)Vuex-and-eventBus/"}}},{"node":{"id":"a27fa596-a553-5452-b719-8382dcb9530e","timeToRead":4,"excerpt":"Let’s Encrypt 갱신 자동화 서비스 환경은 AWS의 EC2(Amazon linux2) + Nginx 조합으로 되어있습니다. *amazon linux2는 apt-get 패키지 관련 명령어 대신 yum 패키지 명령어를 사용합니다. Let’s…","frontmatter":{"title":"(12) Let's Encrypt 갱신 자동화","date":"2021-04-12T10:13:47.149Z"},"fields":{"slug":"/tripllo/(12)aws-lets-encrypt-renewal-automation/"}}},{"node":{"id":"6f438e93-495f-50ba-b3f7-8fec6a0a0040","timeToRead":7,"excerpt":"Sentry Sentry는 Application Error Monitoring…","frontmatter":{"title":"(11) Sentry 에러 로깅 시스템 도입","date":"2021-04-09T17:13:47.149Z"},"fields":{"slug":"/tripllo/(11)vue-sentry-error-monitoring-system/"}}},{"node":{"id":"9d1ff393-5941-52fc-810d-5828a109790e","timeToRead":9,"excerpt":"Travis Travis CI에 대해서 알아보자. 우선 Travis 공식 Docs를 보고 따라해봤다. 참고 자료는 이동욱님의 스프링 부트와 AWS로 혼자 구현하는 웹 서비스 책을 참고했다. 우선 travis endpoint…","frontmatter":{"title":"(10) Frontend -travis 배포 자동화","date":"2021-04-06T17:13:47.149Z"},"fields":{"slug":"/tripllo/(10)vue-travis-automation/"}}},{"node":{"id":"fa1948e0-fc12-5e87-b831-73fdfcbee970","timeToRead":12,"excerpt":"아래 내용은 인프런 멘토링에서 대한민국 Vue 권위자 캡틴판교님께 멘토링 받으며 코드리뷰를 해주신 부분에 대한 반영 내용입니다. 목차 props type plugin 폴더 정리 nextTick 없애기 & 대신 사용자 정의 디렉티브 연결 API…","frontmatter":{"title":"(9) vue 리팩토링2","date":"2021-04-04T19:13:47.149Z"},"fields":{"slug":"/tripllo/(9)vue-refactor2/"}}}]}},"pageContext":{"slug":"/tripllo/(5)login2-SpringBoot/","prev":{"excerpt":"Spring Security와 JWT를 사용해서 로그인 기능을 구현했다. Spring Security와 JWT의 개념을 알아보자. Spring Security Spring Security는 Spring…","timeToRead":5,"frontmatter":{"title":"(4) 로그인1 -SpringSecurity & JWT 개념","tags":["Tripllo 제작기"],"date":"2021-02-04T10:03:47.149Z","draft":false,"excerpt":"Spring Security와 JWT를 사용해서 로그인 기능을 구현했다. Spring Security와 JWT의 개념을 알아보자.","image":{"childImageSharp":{"fluid":{"aspectRatio":2.293577981651376,"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsTAAALEwEAmpwYAAABeklEQVQoz5WQy07CYBCFeSrXPoQb486NOza6My7UGDcsFKMxAQ0QAaOiKCCEchFRLoJcCxTaQNECUq4Vyq30/40pWogrTyaZyWS+M8mRwFkBCL5L0M882QNxLxxLhNbq0Q32Q3SYFcXgfY6ddhfhbO11y7W06VxMVLzsiLHmVLGyx05oEUIXLT8Y08dP5K0d15owRboa9JJGU0ZRaKYncLTsPgqsKkLr/jdLu1/TJ2QXyT1rVo3XYxvIgpc02nKafZ80Q4d2Pcv+oiVEIe785QSmGEJqnl+5mSMacXb0eZ891UR31JFtJ6E3Y0qKwcMlhymjqLNlM6Y0oAeHgbUwhXzDQh7hkvO5eAchHPPcgOvR3fcM/TIaDwDgxzzH8aMxz0EI+1zXjp+ZMGV3yIiBTUcl2DV6FQMqt+U01qzKU7i+SsrP4zILduLAdbacptIhRRgAHgD+N08IYWfYjpRcaTqYqvrzTRSt+uOVR7TqI5upfBPtDFt/P/9PX4zv38RNe7B1AAAAAElFTkSuQmCC","sizes":"(max-width: 788px) 100vw, 788px","src":"/static/f0634ae38a1872124e048bd0df954052/e8f31/tripllo4.png","srcSet":"/static/f0634ae38a1872124e048bd0df954052/53f65/tripllo4.png 500w,\n/static/f0634ae38a1872124e048bd0df954052/e8f31/tripllo4.png 788w"}}},"author":[{"id":"Pozafly","bio":"Frontend Developer","avatar":{"children":[{"fluid":{"aspectRatio":1,"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAACY0lEQVQ4y42UTUhUURTHz7kzFiN9aLsSK5JIGV2URREGBX2ppKGUptVMZYJ9OPPemzfjyloXSDsXtRD6oFVUIFGtTHARFoEgSiFkJRFWGBPavHfvP+6rbLIZ9XIWh8P98T/vvP+5FCVkjAgpi5TpJdnuUMZqO7kJQq3v/lHRH9e8XDysDEKEZ1bw+gKuiP0WV4uC28lJCOyky7nlwUDJxv10PcG6uDAcIWkRzvJ4gPKDTweKeu7kUeFFkTS8jhaE3YQPpXQst66qfgbVX7CkonwHxTtEBnGaQ9qMBnq2dOWqksHRAYmHwLpHfbki/7R4bf03uXRYTyXmRyFty0vYpgJcZ9pxww6WhZo2UW2HLzusGxbYTV3+DWu2v50akgAUlOxTKH017s9bfojuxVlfy6xsCOyjrqLu3isAXCk1DTjSBoo6b1bTDetf8TRlHyzCmUocTKqPjvJ0oeWBEUfu+aTatsAkREXGthkxQpWVuj2Z0sIKv470kmvvUzWhlE2IZIQNgXOEq2XKnfZk/8DKU09OqEur1QWCwVng84T+bpX8hs9j+Dr+NybH8D2J3k7VRjB8Wf6zIRALuIZfmjnSyHFNHdLQ4Rh+GQvIKMv5HBYjmHoxlKlXUk/I9IpRkiapWDaHGXolflSKW838IszDzTxYz49DPBzi0Spxt5XfHeeXTTxoppmcZh0SJxzm3rVib1CEN4v2oAiXiZYCsatYNBaLxgPcs1XYR7jPTjPprLJ+NFroQ4Smmvl5Aw/U8IOTPHyCh07xm1aeqOMnYR6x5lkMryVpkbIJcdKemf1s28vnbOVPfGtgRKO972EAAAAASUVORK5CYII=","sizes":"(max-width: 800px) 100vw, 800px","src":"/static/8c061761f263c344f2c0416607c8adf1/bc8e0/pozafly.png","srcSet":"/static/8c061761f263c344f2c0416607c8adf1/8ac63/pozafly.png 200w,\n/static/8c061761f263c344f2c0416607c8adf1/3891b/pozafly.png 400w,\n/static/8c061761f263c344f2c0416607c8adf1/bc8e0/pozafly.png 800w,\n/static/8c061761f263c344f2c0416607c8adf1/6050d/pozafly.png 1200w,\n/static/8c061761f263c344f2c0416607c8adf1/d4b30/pozafly.png 1242w"}}]}}]},"fields":{"layout":"post","slug":"/tripllo/(4)spring-security-jwt/"}},"next":{"excerpt":"SpringBoot 쪽 서비스 로직이 만들어졌으므로 이번엔 vue에서 화면을 만들고 회원가입과 로그인을 진행해보자. 우리는 vue의 기능을 최대한 살려서 뼈대가 되는 페이지 하나에 login과 signup 2개의 컴포넌트를 붙이고 watch…","timeToRead":6,"frontmatter":{"title":"(6) 로그인3 -vue 구현","tags":["Tripllo 제작기"],"date":"2021-02-05T07:03:47.149Z","draft":false,"excerpt":"SpringBoot 쪽 서비스 로직이 만들어졌으므로 이번엔 vue에서 화면을 만들고 회원가입과 로그인을 진행해보자. 우리는 vue의 기능을 최대한 살려서 뼈대가 되는 페이지 하나에 login과 signup 2개의 컴포넌트를 붙이고 watch를 활용해 데이터를 검증할 것이다.","image":{"childImageSharp":{"fluid":{"aspectRatio":0.7429420505200595,"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAbCAYAAAB836/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAADEklEQVRIx5WVy04UQRSGeShXPo1LE4lRdiYYdeFKJCZsVIK8gVtfQBYEwmYgSCIRoWf6Pj19q3v1b051TztAj0gnX6aq5tRf/6muOr0ilYGQ+hZKGXw5irF7FMPLOCguyAUupxzWDM+hmJV5Yw71tTZIK4kH26d4uPMDX49TbHz3sfbtEpt7PhpjW5GFeVK1oiutyO0VudD4lTJcpAxWG4wmFU7DGrNagQ+4I43eIRcSTEgXuIgxxsGorTWMUpAUxyXYDbhQrUNqkF00DazgsJy1CA7DGAznsKyG1Rq2adAMQI+UyomuMCagaOBgD+naI2RvniN7uYrsxWNkr54iW3+CbH0V2etnaJRyk9GJtM0lgvrsGPnWW5Q7H1B8fo/i4zsU25soPm207G45l00nstwhpSwV7vM0vcMhQU57qNo9NKbDAtZiPIkQhimiaIokyeD5McJ42osOO5wLDjyzWYG8KFGUFTgXrl1VbDBW/BWU0Fojqy3OvRRnFwEuwxxxoZBWuicp6dcgLTWiXPYEM4lZbaCUApnrBaPCYPRzjKOTcyeclAZBJhDMbhPOZM9kKhDldLsWBJXSMNYiryUqrpFXAmleoaglSqbuxFrrtq1PmTrWNkjTFGEYwg8CBEEALoS717TgchSMsYsvpXVIq9DGLkJXkqCbRBOGoDjnUA44DKMYEz+AN570RFEMpQ0EiQ5AgnTfBxw2fRD1KVVtzJ0pUzydxUGHUZzA9wOMJz6qmnX1UQ06+w+H7T5QesR8f+QdLN/DpkGcpG4f/SAE4wLa2H6BZVAWg2+ZbJdlhaIsURQlasbAOAdj3LVdn/HrdP+7lBfPIR3qJEmwv7+Pw8NDx8HBgYPaJyfHGI1GOOzGFqE50+nUZUNa3dUzYIzh6srDeDx2eAv4vo+J718b7+M8D5xzl2V39ZZXm/s8g+WLjg4VTa4MzhOOi6nAJRWIQsKbSfzOBCa5dGNS27aG/qsezoulsQ1KYVBLg0oaMGVRS4taWXBt3dhc6FaBnX9Gefd5dAgJJSXkEKL9vRlP0Gf0Dxz6HIqb0rgiAAAAAElFTkSuQmCC","sizes":"(max-width: 505px) 100vw, 505px","src":"/static/091b93c48a5a6d44022278f6ff3b1035/08a05/tripllo6.png","srcSet":"/static/091b93c48a5a6d44022278f6ff3b1035/53f65/tripllo6.png 500w,\n/static/091b93c48a5a6d44022278f6ff3b1035/08a05/tripllo6.png 505w"}}},"author":[{"id":"Pozafly","bio":"Frontend Developer","avatar":{"children":[{"fluid":{"aspectRatio":1,"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAACXBIWXMAAAsTAAALEwEAmpwYAAACY0lEQVQ4y42UTUhUURTHz7kzFiN9aLsSK5JIGV2URREGBX2ppKGUptVMZYJ9OPPemzfjyloXSDsXtRD6oFVUIFGtTHARFoEgSiFkJRFWGBPavHfvP+6rbLIZ9XIWh8P98T/vvP+5FCVkjAgpi5TpJdnuUMZqO7kJQq3v/lHRH9e8XDysDEKEZ1bw+gKuiP0WV4uC28lJCOyky7nlwUDJxv10PcG6uDAcIWkRzvJ4gPKDTweKeu7kUeFFkTS8jhaE3YQPpXQst66qfgbVX7CkonwHxTtEBnGaQ9qMBnq2dOWqksHRAYmHwLpHfbki/7R4bf03uXRYTyXmRyFty0vYpgJcZ9pxww6WhZo2UW2HLzusGxbYTV3+DWu2v50akgAUlOxTKH017s9bfojuxVlfy6xsCOyjrqLu3isAXCk1DTjSBoo6b1bTDetf8TRlHyzCmUocTKqPjvJ0oeWBEUfu+aTatsAkREXGthkxQpWVuj2Z0sIKv470kmvvUzWhlE2IZIQNgXOEq2XKnfZk/8DKU09OqEur1QWCwVng84T+bpX8hs9j+Dr+NybH8D2J3k7VRjB8Wf6zIRALuIZfmjnSyHFNHdLQ4Rh+GQvIKMv5HBYjmHoxlKlXUk/I9IpRkiapWDaHGXolflSKW838IszDzTxYz49DPBzi0Spxt5XfHeeXTTxoppmcZh0SJxzm3rVib1CEN4v2oAiXiZYCsatYNBaLxgPcs1XYR7jPTjPprLJ+NFroQ4Smmvl5Aw/U8IOTPHyCh07xm1aeqOMnYR6x5lkMryVpkbIJcdKemf1s28vnbOVPfGtgRKO972EAAAAASUVORK5CYII=","sizes":"(max-width: 800px) 100vw, 800px","src":"/static/8c061761f263c344f2c0416607c8adf1/bc8e0/pozafly.png","srcSet":"/static/8c061761f263c344f2c0416607c8adf1/8ac63/pozafly.png 200w,\n/static/8c061761f263c344f2c0416607c8adf1/3891b/pozafly.png 400w,\n/static/8c061761f263c344f2c0416607c8adf1/bc8e0/pozafly.png 800w,\n/static/8c061761f263c344f2c0416607c8adf1/6050d/pozafly.png 1200w,\n/static/8c061761f263c344f2c0416607c8adf1/d4b30/pozafly.png 1242w"}}]}}]},"fields":{"layout":"post","slug":"/tripllo/(6)login3-vue/"}},"primaryTag":"Tripllo 제작기"}},"staticQueryHashes":["1917168614","4083712403"]}